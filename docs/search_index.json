[["index.html", "MODELOS SEMI ESTRUCTURALES PARA EL CRÉDITO AL CONSUMO Capítulo 1 Aplicación para Guatemala 1.1 Blanchard-Quah ortogonalización (restricciones) sobre C(1) Referencias", " MODELOS SEMI ESTRUCTURALES PARA EL CRÉDITO AL CONSUMO Luis Ortiz-Cevallos 2023-03-31 Capítulo 1 Aplicación para Guatemala 1.1 Blanchard-Quah ortogonalización (restricciones) sobre C(1) Al observar la evolución del crédito hacia consumo provisto por el sistema bancario guatemalteco y disponible en Secretaría Ejecutiva del Consejo Monetario Centroamericano (2023), se observa una series con una tendendencia estocástica. library(&quot;zoo&quot;) library(&quot;xts&quot;) library(dplyr) library(ggplot2) library(kableExtra) library(xtable) library(tidyr) library(quantmod) library(RColorBrewer) library(gridExtra) #CARGAMOS DATOS MENSUALES DATA_MES&lt;-as.xts(read.zoo(&quot;GT_MES.csv&quot;, index.column = 1, sep = &quot;;&quot;, header=TRUE, format = &quot;%Y-%m-%d&quot;)) CREDITO&lt;-DATA_MES$CRED CREDITO&lt;-data.frame(date=index(CREDITO), coredata(CREDITO)) CREDITO&lt;-filter(CREDITO, date &gt;= &quot;2008-01-01&quot;) colnames(CREDITO)&lt;-c(&quot;date&quot;,&quot;CREDITO&quot;) CREDITO&lt;-mutate(CREDITO, CONSUMO=log(CREDITO)) G&lt;-ggplot(CREDITO, aes(x=date, y=CONSUMO)) G&lt;-G+labs(y=&quot;Logaritmo&quot;, x=&quot;Fecha&quot;, title = &quot;Guatemala: evolución del crédito al consumo&quot;, caption = &quot;https://www.secmca.org/wp-content/uploads/2023/03/REPORTE_INDICADO RES_BANCARIOS_MARZO_2023.xlsx&quot;)+ geom_line(size=1.5) G El proceso de generación de la serie del crédito al consumo puede explicarse a través de la identificación de diferentes innovaciones. Una de ellas, las llamaré tecnológicas (en general uso ese término para referir los factores que pueden producir una mayor inclusión financiera independientemente si es producto de políticas o nuevas tecnologías), la segunda las de denanda y la tercera de absorción fiscal. Para este ejercicio de identificación sigo la metodología propuesta por Blanchard and Quah (1988) y estimo la forma reducida de un Vector Autorregresivo integrado por la tasa de crecimiento de la cartera de consumo nominal (\\(\\Delta c_{t}\\)), la tasa de crecimiento del PIB (\\(\\Delta y_{t}\\)) y el porcentaje de los activos de los sistemas bancarios en títulos y valores públicos (\\(\\Delta y_{t}\\)). La representación de este VAR como un proceso de media móviles está dado por: \\[\\begin{equation} X_{t}=\\left( \\begin{array}{c} \\Delta c_{t} \\\\ \\Delta y_{t} \\\\ \\Delta x_{t} \\end{array} \\right)=A(L)e_{t} \\label{e1} \\end{equation}\\] Considero \\(A(0)=I\\) y \\(\\Sigma_e=E(e e^{\\tau})\\) como la matriz de varianza y covarianza de la forma reducida del VAR mostrado en \\(\\ref{e1}\\). Y supongo, primero que el crédito hacia consumo, la actividad económica y la exposición del sistema bancario hacia valores del gobierno son producidos a través de tres procesos estructurales independientes con shocks de varianza unitaria. Y segundo, que uno de esos procesos, el de las innovaciones tecnológicas, es el responsable de la tendencia estocástica observada en el crédito para consumo. Con base en lo anterior defino un VAR estructural cuya representación como un proceso de medias móviles es el siguiente: \\[\\begin{equation} X_{t}=C(L)\\epsilon_{t}=\\left( \\begin{array}{ccc} C_{1,1}(L) &amp; C_{1,2}(L) &amp; C_{1,3}(L)\\\\ C_{2,1}(L) &amp; C_{2,2}(L) &amp; C_{2,3}(L)\\\\ C_{3,1}(L) &amp; C_{3,2}(L) &amp; C_{3,3}(L) \\end{array} \\right)\\epsilon_{t} \\label{e2} \\end{equation}\\] Siendo \\(\\Sigma_{\\epsilon}=E(\\epsilon \\epsilon^{\\tau})=I\\) la matriz de varianza y covarianza de los shocks estructurales, los cuales son independientes y con varianza unitaria, y \\(C_{1,2}(1)=C_{1,3}(1)=0\\), indicando que el shock de demanda y fiscal sobre las variables tasa de crecimiento del PIB y porcentaje de activos invertidos en valores soberanos, en su orden, no tienen efectos de largo plazo en el crédito nominal para consumo. El proceso y resultado de la estimación es el siguiente: CRED &lt;-DATA_MES$CRED FISCAL &lt;-DATA_MES$PUB CRED &lt;-CRED[&quot;2008-01-01/2022-09-01&quot;] ep1 &lt;-endpoints(CRED , on = &quot;quarters&quot;) CRED &lt;-period.apply(CRED , INDEX = ep1, FUN = sum) DCRED &lt;-diff(100*log(CRED ), lag=4) FISCAL &lt;-FISCAL[&quot;2008-01-01/2022-09-01&quot;] ep2 &lt;-endpoints(FISCAL , on = &quot;quarters&quot;) TASA &lt;-period.apply(FISCAL, INDEX = ep2, FUN = max) DATA_TRIM &lt;-as.xts(read.zoo(&quot;TRIM_GT.csv&quot;, index.column = 1, sep = &quot;;&quot;, header=TRUE, format = &quot;%Y-%m-%d&quot;)) PIB &lt;-DATA_TRIM$PIB PIB &lt;-PIB[&quot;2001-03-01/2022-09-01&quot;] DPIB &lt;-diff(100*log(PIB), lag=4) #COMBINAR BASE &lt;-merge(DCRED, DPIB,join=&quot;left&quot;) BASE &lt;-merge(BASE, FISCAL,join=&quot;left&quot;) BASE &lt;-data.frame(date=index(BASE), coredata(BASE)) colnames(BASE)&lt;-c(&quot;date&quot;,&quot;c&quot;, &quot;y&quot;, &#39;x&#39;) DATA &lt;-dplyr::select(BASE, date, c,y,x) colnames(DATA)&lt;-c(&quot;date&quot;, &quot;c&quot;, &quot;y&quot;, &#39;x&#39;) DATA &lt;-filter(DATA, date &gt;= &quot;2016-03-01&quot;) DATA &lt;-xts(DATA[,-1], order.by=as.Date(DATA[,1], &quot;%Y/%m/%d&quot;)) library(&quot;svars&quot;) VAR &lt;- vars::VAR(DATA[,c(1,2,3)],p =2,type = &quot;const&quot;) VAR$varresult$c$coefficients ## c.l1 y.l1 x.l1 c.l2 y.l2 x.l2 ## 1.12127681 0.15372782 0.29159136 -0.11201301 -0.01109658 0.18036079 ## const ## -9.91395632 VAR$varresult$y$coefficients ## c.l1 y.l1 x.l1 c.l2 y.l2 x.l2 ## -0.25412909 0.57678412 0.39960337 0.27004423 -0.15357170 -0.02784201 ## const ## -5.84527946 VAR$varresult$x$coefficients ## c.l1 y.l1 x.l1 c.l2 y.l2 x.l2 ## 0.18016081 -0.13225215 0.28849915 -0.26998876 -0.03531496 0.45762387 ## const ## 6.70493277 SIGMA&lt;-summary(VAR) SIGMA$covres ## c y x ## c 1.2422579 2.067672 0.1369263 ## y 2.0676722 13.450295 0.5679060 ## x 0.1369263 0.567906 1.6557099 Habiendo estimado el VAR a continuación encontramos las restricciones de corto o contemporáneas y largo plazo: BQMODEL&lt;- BQ(VAR) summary(BQMODEL) ## ## SVAR Estimation Results: ## ======================== ## ## Call: ## BQ(x = VAR) ## ## Type: Blanchard-Quah ## Sample size: 25 ## Log Likelihood: -144.025 ## ## Estimated contemporaneous impact matrix: ## c y x ## c 0.45904 0.3686 -0.9464 ## y 0.08455 3.5899 -0.7455 ## x 1.15782 0.2366 0.5091 ## ## Estimated identified long run impact matrix: ## c y x ## c 16.7627 0.000 0.000 ## y -0.1924 4.788 0.000 ## x -1.2435 -2.228 2.005 ## ## Covariance matrix of reduced form residuals (*100): ## c y x ## c 124.23 206.77 13.69 ## y 206.77 1345.03 56.79 ## x 13.69 56.79 165.57 En seguida, calculamos la función impulso respuesta para cada variable, teniendo en cuenta que el PIB y la proporción de activos del sistema bancario invertidos en títulos y valores del gobierno no sufren en el largo plazo ningún efecto de los tres shocks estructurales. FIR_BQ &lt;- irf(BQMODEL,n.ahead = 32, impulse = c( &quot;c&quot;, &quot;y&quot;, &quot;x&quot;), boot =FALSE) tecno &lt;- cbind(cumsum(FIR_BQ$irf$c[, 1]), FIR_BQ$irf$c[, 2], FIR_BQ$irf$c[, 3]) RESULTADO1&lt;-as.data.frame(tecno) PERIODO&lt;-seq(1,33,1) RESULTADO1 &lt;-cbind(RESULTADO1,PERIODO) CODE&lt;-rep(&quot;Tecnológico&quot;,33) RESULTADO1 &lt;-cbind(RESULTADO1,CODE) ###################################### demanda &lt;- cbind(FIR_BQ$irf$y[, 1], FIR_BQ$irf$y[, 2], FIR_BQ$irf$y[, 3]) RESULTADO2&lt;-as.data.frame(demanda) RESULTADO2 &lt;-cbind(RESULTADO2,PERIODO) CODE&lt;-rep(&quot;Demanda&quot;,33) RESULTADO2 &lt;-cbind(RESULTADO2,CODE) ###################################### fiscal &lt;- cbind(-1*FIR_BQ$irf$x[, 1], -1*FIR_BQ$irf$x[, 2], -1*FIR_BQ$irf$x[, 3]) RESULTADO3 &lt;-as.data.frame(fiscal) RESULTADO3 &lt;-cbind(RESULTADO3,PERIODO) CODE&lt;-rep(&quot;Fiscal&quot;,33) RESULTADO3&lt;-cbind(RESULTADO3,CODE) RESULTADO &lt;-rbind(RESULTADO1,RESULTADO2,RESULTADO3) BASE_LONG &lt;- gather(RESULTADO, key=&quot;measure&quot;, value=&quot;value&quot;,c(&quot;V1&quot;, &quot;V2&quot;, &quot;V3&quot;)) BASE_LONG$measure &lt;- factor(BASE_LONG$measure,levels = ,c(&quot;V1&quot;, &quot;V2&quot;, &quot;V3&quot;)) BASE_LONG$CODE &lt;- factor(BASE_LONG$CODE,levels = c(&quot;Tecnológico&quot;, &quot;Demanda&quot;, &quot;Fiscal&quot;)) variable_names &lt;- list( &quot;Tecnológico&quot; = &quot;Shock tecnológicos&quot;, &quot;Demanda&quot; = &quot;Shock de demanda&quot;, &quot;Fiscal&quot; = &quot;Shock fiscal&quot; ) variable_labeller2 &lt;- function(variable,value){ if (variable==&#39;CODE&#39;) { return(variable_names[value]) } else { return(region_names) } } paleta&lt;-c(&quot;blue&quot;,&quot;red&quot;, &quot;burlywood&quot;) Z&lt;-ggplot(BASE_LONG, aes(x=PERIODO, y=value, group = measure, colour=measure))+ facet_wrap(.~CODE, scales=&quot;free&quot;, labeller= variable_labeller2) Z&lt;-Z+labs(y=&quot;Respuesta (%)&quot;, x=&quot;Períodos (trimestres)&quot;, title = &quot;Guatemala: funciones impulso respuestas&quot;, caption = &quot;Elaboración propia con base en: https://www.secmca.org/wp-content/uploads/2023/03/REPORTE_INDICADO RES_BANCARIOS_MARZO_2023.xlsx&quot;)+ geom_hline(yintercept=0, linetype=&quot;dashed&quot;, color = &quot;black&quot;, size=1)+ geom_line(size=1.5)+ scale_color_manual(values=paleta, labels = c(&quot;Crédito para consumo&quot;, &quot;Producto&quot;, &quot;Proporción de los activos invertidos en valores públicos&quot; )) Z&lt;-Z+theme(axis.line.x = element_line(colour = &quot;black&quot;, size = 0.5), axis.line.y.left = element_line(colour = &quot;black&quot;, size = 0.5), axis.line.y.right = element_blank(), axis.text.x = element_text( color = &quot;black&quot;, size = 14), axis.text.y = element_text( color = &quot;black&quot;, size = 14), axis.title.x = element_text( color = &quot;black&quot;, size = 15), axis.title.y = element_text( color = &quot;black&quot;, size = 15), panel.grid.minor = element_blank(), panel.grid.major.y = element_blank(), panel.grid.major.x = element_blank(), panel.border = element_blank(), panel.background = element_blank(), legend.key=element_rect(fill = &quot;white&quot;, colour = &quot;white&quot;, color = &quot;white&quot;, inherit.blank = FALSE), legend.title = element_blank(), legend.text = element_text(size=18), legend.position=&quot;bottom&quot;, legend.spacing.x = unit(0.10, &#39;cm&#39;), legend.margin=margin(), legend.background = element_rect(fill = &quot;white&quot;, colour = &quot;transparent&quot;, color = &quot;white&quot;, inherit.blank = FALSE), strip.text.x = element_text( size = 20, color = &quot;black&quot;, face = &quot;bold.italic&quot; ) )+guides(color = guide_legend(nrow = 1))+ scale_x_continuous(breaks=seq(0,32,4)) Z Inplicaciones #Descomposición de la varianza HISTÓRICA ##FUNCIONES VARhd &lt;- function(Estimation){ ## make X and Y nlag &lt;- Estimation$p # number of lags DATA &lt;- Estimation$y # data QQ &lt;- VARmakexy(DATA,nlag,1) #invA &lt;- t(chol(as.matrix(summary(Estimation)$covres)))# inverse of the A matrix invA &lt;- BQMODEL$LRIM #invA &lt;- bqfactor Fcomp &lt;- companionmatrix(Estimation) # Companion matrix #det &lt;- c_case # constant and/or trends F1 &lt;- t(QQ$Ft) # make comparable to notes eps &lt;- ginv(invA) %*% t(residuals(Estimation)) # structural errors nvar &lt;- Estimation$K # number of endogenous variables nvarXeq &lt;- nvar * nlag # number of lagged endogenous per equation nvar_ex &lt;- 0 # number of exogenous (excluding constant and trend) Y &lt;- QQ$Y # left-hand side #X &lt;- QQ$X[,(1+det):(nvarXeq+det)] # right-hand side (no exogenous) nobs &lt;- nrow(Y) # number of observations ## Compute historical decompositions # Contribution of each shock invA_big &lt;- matrix(0,nvarXeq,nvar) invA_big[1:nvar,] &lt;- invA Icomp &lt;- cbind(diag(nvar), matrix(0,nvar,(nlag-1)*nvar)) HDshock_big &lt;- array(0, dim=c(nlag*nvar,nobs+1,nvar)) HDshock &lt;- array(0, dim=c(nvar,(nobs+1),nvar)) for (j in 1:nvar){ # for each variable eps_big &lt;- matrix(0,nvar,(nobs+1)) # matrix of shocks conformable with companion eps_big[j,2:ncol(eps_big)] &lt;- eps[j,] for (i in 2:(nobs+1)){ HDshock_big[,i,j] &lt;- invA_big %*% eps_big[,i] + Fcomp %*% HDshock_big[,(i-1),j] HDshock[,i,j] &lt;- Icomp %*% HDshock_big[,i,j] } } HD.shock &lt;- array(0, dim=c((nobs+nlag),nvar,nvar)) # [nobs x shock x var] for (i in 1:nvar){ for (j in 1:nvar){ HD.shock[,j,i] &lt;- c(rep(NA,nlag), HDshock[i,(2:dim(HDshock)[2]),j]) } } return(HD.shock) } ########## VARmakexy &lt;- function(DATA,lags,c_case){ nobs &lt;- nrow(DATA) #Y matrix Y &lt;- DATA[(lags+1):nrow(DATA),] Y &lt;- DATA[-c(1:lags),] #X-matrix if (c_case==0){ X &lt;- NA for (jj in 0:(lags-1)){ X &lt;- rbind(DATA[(jj+1):(nobs-lags+jj),]) } } else if(c_case==1){ #constant X &lt;- NA for (jj in 0:(lags-1)){ X &lt;- rbind(DATA[(jj+1):(nobs-lags+jj),]) } X &lt;- cbind(matrix(1,(nobs-lags),1), X) } else if(c_case==2){ # time trend and constant X &lt;- NA for (jj in 0:(lags-1)){ X &lt;- rbind(DATA[(jj+1):(nobs-lags+jj),]) } trend &lt;- c(1:nrow(X)) X &lt;-cbind(matrix(1,(nobs-lags),1), t(trend)) } A &lt;- (t(X) %*% as.matrix(X)) B &lt;- (as.matrix(t(X)) %*% as.matrix(Y)) Ft &lt;- ginv(A) %*% B retu &lt;- list(X=X,Y=Y, Ft=Ft) return(retu) } companionmatrix &lt;- function (x) { if (!(class(x) == &quot;varest&quot;)) { stop(&quot;\\nPlease provide an object of class &#39;varest&#39;, generated by &#39;VAR()&#39;.\\n&quot;) } K &lt;- x$K p &lt;- x$p A &lt;- unlist(Acoef(x)) companion &lt;- matrix(0, nrow = K * p, ncol = K * p) companion[1:K, 1:(K * p)] &lt;- A if (p &gt; 1) { j &lt;- 0 for (i in (K + 1):(K * p)) { j &lt;- j + 1 companion[i, j] &lt;- 1 } } return(companion) } SERIE &lt;-fitted(VAR) BQh&lt;-VARhd(VAR) dates1&lt;- seq(as.Date(&quot;2016-03-01&quot;), length=length(SERIE[,1])+2,by=&quot;quarters&quot;) BQc_T&lt;-BQh[,1,1] #SHOCK TECNOLÓGICO SOBRE c BQc_T&lt;-xts(BQc_T, order.by=dates1) BQc_D&lt;-BQh[,1,2] #SHOCK DEMANDA SOBRE c BQc_D&lt;-xts(BQc_D, order.by=dates1) BQc_F&lt;-BQh[,1,3] #SHOCK DEMANDA2 SOBRE c BQc_F&lt;-xts(BQc_F, order.by=dates1) Referencias "]]
